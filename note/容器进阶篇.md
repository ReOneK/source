### 1.什么是容器

> 容器其实是一种沙盒技术（sandbox）。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了**边界**而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去，这就是 PaaS 最理想的状态。



### 2.关于“边界”

> 当程序运行起来，它就从磁盘上的二进制文件，变成了计算机`内存中的数据`、`寄存器里的值`、`堆栈中的指令`、`被打开的文件`，以及`各种设备的状态信息`的一个集合：**进程**。
>
> 对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和**状态的总和**，这就是它的**动态表现**。

**容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”**

- Cgroups 技术是用来制造约束的主要手段（`资源隔离`）
- Namespace 技术则是用来修改进程视图的主要方法（`视图隔离`）



### 3.Namespace机制

> 当我们在宿主机上运行了一个 /bin/sh 程序，操作系统都会给它分配一个进程编号，比如 PID=100。（linux通过clone来创建新的进程，Namespace为一个可选参数）
>
> > （int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL)）
>
> 我们要通过 Docker 把这个 /bin/sh 程序运行在一个容器当中。这时候，Docker 就会在这个第 100 号进程施一个“障眼法”，让他永远看不到前面的其他 99 个进程。
>
> 这种机制，其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。
>
> 除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。

![img](C:\Users\95951\Desktop\source\pic\容器基础篇1.jpg)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



- 这幅图的左边，画出了虚拟机的工作原理。其中，名为 Hypervisor 的软件是虚拟机最主要的部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS。这样，用户的应用进程就可以运行在这个虚拟的机器中，它能看到的自然也只有 Guest OS 的文件和目录，以及这个机器里的虚拟设备。这就是为什么虚拟机也能起到将不同的应用进程相互隔离的作用。
- 而这幅图的右边，则用一个名为 Docker Engine 的软件替换了 Hypervisor。这也是为什么，很多人会把 Docker 项目称为“轻量级”虚拟化技术的原因，实际上就是把虚拟机的概念套在了容器上。



### 4.Docker VS 虚拟机

- 使用虚拟化技术作为应用沙盒，就必须要由 Hypervisor(KVM等) 来负责创建虚拟机，这个虚拟机是真实存在的，并且它里面必须运行一个完整的 Guest OS 才能执行用户的应用进程。这就不可避免地带来了额外的资源消耗和占用。
- 容器化后的用户应用，却依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。

优势：`敏捷，高性能`

劣势：`隔离不彻底`

- 多个容器之间使用的就还是同一个宿主机的操作系统内核（无法运行其它版本主机windows或者其它版本linux）。
- 在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。



### 5.Linux Cgroups(Control Group)

> 最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。
>
> 在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。

![img](C:\Users\95951\Desktop\source\pic\容器基础篇2.jpg)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑



- 容器是一个“单进程”模型（一个进程）
- 用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程
- 在一个容器中，你没办法同时运行两个不同的应用，除非你能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程，这也是为什么很多人都会用 systemd 或者 supervisord 这样的软件来代替应用本身作为容器的启动进程。



**推荐阅读**：